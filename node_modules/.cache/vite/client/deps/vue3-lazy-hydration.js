import {
  computed,
  createVNode,
  defineComponent,
  getCurrentInstance,
  handleError,
  isRef,
  isVNode,
  markRaw,
  nextTick,
  onBeforeMount,
  onMounted,
  onUnmounted,
  ref,
  toRef,
  unref,
  watch
} from "./chunk-MRB5GWAV.js";
import "./chunk-Y2F7D3TJ.js";

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/create-hydration-cleanup.mjs
function createHydrationCleanup() {
  let cleanups = [];
  const onCleanup = (cb) => {
    cleanups.push(cb);
  };
  const cleanup = () => {
    cleanups = cleanups.filter((fn) => {
      fn();
      return false;
    });
  };
  return { cleanup, onCleanup };
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/create-hydration-promise.mjs
function createHydrationPromise(cleanup) {
  let resolvePromise = () => {
  };
  const promise = new Promise((resolve) => {
    resolvePromise = () => {
      cleanup();
      resolve();
    };
  });
  const onResolvedPromise = (cb) => {
    void promise.then(cb);
  };
  return {
    promise,
    resolvePromise,
    onResolvedPromise
  };
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/track-deps-on-render.mjs
function trackDepsOnRender(instance) {
  const componentUpdateFn = instance.effect.fn;
  const originalRender = instance.render;
  instance.render = (...args) => {
    instance.effect.fn = () => originalRender(...args);
    const result = instance.effect.run();
    instance.effect.fn = componentUpdateFn;
    instance.render = originalRender;
    return result;
  };
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/helpers.mjs
var isFunction = (val) => typeof val === "function";
var isObject = (val) => val !== null && typeof val === "object";

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/traverse-children.mjs
function traverseChildren(vnode, fn) {
  if (!isVNode(vnode)) {
    return;
  }
  fn(
    vnode
  );
  if (vnode.children === null) {
    return;
  }
  if (Array.isArray(vnode.children)) {
    vnode.children.forEach((child) => traverseChildren(child, fn));
    return;
  }
  if (isObject(vnode.children)) {
    Object.keys(vnode.children).forEach((slotName) => {
      if (!isFunction(vnode.children[slotName])) {
        return;
      }
      const slotContent = vnode.children[slotName]();
      if (Array.isArray(slotContent)) {
        slotContent.forEach((child) => traverseChildren(child, fn));
        return;
      }
      traverseChildren(slotContent, fn);
    });
  }
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/wait-for-async-components.mjs
function isAsyncWrapper(vnode) {
  var _a, _b;
  return ((_a = vnode.type) == null ? void 0 : _a.__asyncLoader) && ((_b = vnode.type) == null ? void 0 : _b.name) === "AsyncComponentWrapper";
}
function waitForAsyncComponents({ subTree }, cb) {
  const promises = [];
  traverseChildren(subTree, (vnode) => {
    if (isAsyncWrapper(vnode)) {
      promises.push(vnode.type.__asyncLoader());
    }
  });
  if (promises.length > 0) {
    void Promise.all(promises).then(cb);
    return;
  }
  cb();
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/ensure-parent-has-subtree-el.mjs
function ensureParentHasSubTreeEl(parent) {
  if (!parent || !parent.subTree) {
    return;
  }
  const parentSubTreeEl = parent.subTree.el;
  const parentOnUpdatedHook = parent.u;
  if (parent.u === null) {
    parent.u = [];
  }
  parent.u.push(() => {
    if (parent.subTree.el === null) {
      parent.subTree.el = parentSubTreeEl;
    }
    parent.u = parentOnUpdatedHook;
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/composables/useLazyHydration.mjs
function useLazyHydration() {
  const instance = getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error("useLazyHydration must be called from the setup method.");
  }
  const willPerformHydration = instance.vnode.el !== null;
  instance.vnode.type.__isLazilyHydrated = true;
  if (!willPerformHydration) {
    return { willPerformHydration, onHydrated: () => {
    } };
  }
  const { cleanup, onCleanup } = createHydrationCleanup();
  const {
    promise,
    resolvePromise: hydrate,
    onResolvedPromise: onBeforeHydrate
  } = createHydrationPromise(cleanup);
  const onHydrated = (cb) => onBeforeHydrate(() => nextTick(() => waitForAsyncComponents(instance, cb)));
  instance.type.__asyncLoader = () => promise;
  ensureParentHasSubTreeEl(
    instance.parent
  );
  onBeforeMount(() => {
    instance.asyncDep = new Promise((r) => {
      r(true);
    });
  });
  onBeforeHydrate(() => {
    trackDepsOnRender(
      instance
    );
    instance.asyncDep = null;
  });
  onUnmounted(cleanup);
  return { willPerformHydration, hydrate, onHydrated, onCleanup };
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/composables/useHydrateWhenIdle.mjs
function useHydrateWhenIdle({
  willPerformHydration,
  hydrate,
  onCleanup
}, timeout = 2e3) {
  if (!willPerformHydration) {
    return;
  }
  if (!getCurrentInstance()) {
    throw new Error(
      "useHydrateWhenIdle must be called from the setup or lifecycle hook methods."
    );
  }
  if (!("requestIdleCallback" in window)) {
    hydrate();
    return;
  }
  const idleId = requestIdleCallback(
    () => {
      hydrate();
    },
    { timeout }
  );
  onCleanup(() => {
    cancelIdleCallback(idleId);
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/get-root-elements.mjs
var DOMNodeTypes = {
  ELEMENT: 1,
  TEXT: 3,
  COMMENT: 8
};
var isElement = (node) => node && node.nodeType === DOMNodeTypes.ELEMENT;
var isComment = (node) => node && node.nodeType === DOMNodeTypes.COMMENT;
var isFragmentStart = (node) => isComment(node) && (node == null ? void 0 : node.data) === "[";
var isFragmentEnd = (node) => isComment(node) && (node == null ? void 0 : node.data) === "]";
function getRootElements({
  vnode,
  subTree
}) {
  if (!vnode || vnode.el === null) {
    return [];
  }
  if (isElement(vnode.el)) {
    return [vnode.el];
  }
  const els = [];
  if (subTree && isFragmentStart(subTree.el) && isFragmentEnd(subTree.anchor)) {
    let node = vnode.el.nextSibling;
    while (node) {
      if (node && isElement(node)) {
        els.push(node);
      }
      if (node === subTree.anchor) {
        return els;
      }
      node = node.nextSibling;
    }
  }
  return els;
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/composables/useHydrateOnInteraction.mjs
function useHydrateOnInteraction({
  willPerformHydration,
  hydrate,
  onCleanup
}, events = ["focus"]) {
  if (!willPerformHydration) {
    return;
  }
  const instance = getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error(
      "useHydrateOnInteraction must be called from the setup method."
    );
  }
  const eventsTypes = unref(events);
  onMounted(() => {
    const targets = getRootElements(instance);
    const container = targets.length > 1 ? targets[0].parentElement || document : targets[0];
    const eventListenerOptions = {
      capture: true,
      once: false,
      passive: true
    };
    const listener = (event) => {
      event.stopPropagation();
      const paths = event.composedPath && event.composedPath() || event.path;
      if (!paths) {
        let el = event.target;
        while (el) {
          if (targets.includes(el)) {
            hydrate();
            return;
          }
          if (el === container) {
            return;
          }
          el = el.parentElement;
        }
        return;
      }
      targets.forEach((target) => {
        if (paths.includes(target)) {
          hydrate();
        }
      });
    };
    eventsTypes.forEach((eventType) => {
      container.addEventListener(eventType, listener, eventListenerOptions);
    });
    onCleanup(() => {
      eventsTypes.forEach((eventType) => {
        container.removeEventListener(
          eventType,
          listener,
          eventListenerOptions
        );
      });
    });
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/composables/useHydrateWhenTriggered.mjs
function useHydrateWhenTriggered({
  willPerformHydration,
  hydrate,
  onCleanup
}, trigger) {
  if (!willPerformHydration) {
    return;
  }
  if (!getCurrentInstance()) {
    throw new Error(
      "useHydrateWhenTriggered must be called from the setup or lifecycle hook methods."
    );
  }
  const unWatch = watch(
    isRef(trigger) ? trigger : () => trigger,
    (isTriggered) => {
      if (isTriggered) {
        hydrate();
      }
    },
    {
      immediate: true
    }
  );
  onCleanup(unWatch);
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/create-hydration-observer.mjs
var observers = /* @__PURE__ */ new Map();
function createHydrationObserver(options) {
  const supported = typeof IntersectionObserver !== "undefined";
  if (!supported) {
    return { supported };
  }
  const optionKey = JSON.stringify(options);
  if (observers.has(optionKey)) {
    return { supported, observer: observers.get(optionKey) };
  }
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(
      (entry) => {
        const isIntersecting = entry.isIntersecting || entry.intersectionRatio > 0;
        if (!isIntersecting || !entry.target.hydrate) {
          return;
        }
        entry.target.hydrate();
      }
    );
  }, options);
  observers.set(optionKey, observer);
  return { supported, observer };
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/composables/useHydrateWhenVisible.mjs
function useHydrateWhenVisible({
  willPerformHydration,
  hydrate,
  onCleanup
}, observerOptions) {
  if (!willPerformHydration) {
    return;
  }
  const instance = getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error(
      "useHydrateWhenVisible must be called from the setup method."
    );
  }
  const { supported, observer } = createHydrationObserver(observerOptions);
  if (!supported) {
    hydrate();
    return;
  }
  onMounted(() => {
    const els = getRootElements(instance);
    els.forEach((target) => {
      target.hydrate = hydrate;
      observer.observe(target);
    });
    onCleanup(() => {
      els.forEach((target) => {
        delete target.hydrate;
        observer.unobserve(target);
      });
    });
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/components/LazyHydrationWrapper.mjs
var normalizeSlot = (slotContent) => slotContent.length === 1 ? slotContent[0] : slotContent;
var LazyHydrationWrapper = defineComponent({
  name: "LazyHydrationWrapper",
  inheritAttrs: false,
  suspensible: false,
  props: {
    whenIdle: {
      default: false,
      type: [Boolean, Number]
    },
    whenVisible: {
      default: false,
      type: [Boolean, Object]
    },
    onInteraction: {
      default: false,
      type: [Array, Boolean, String]
    },
    whenTriggered: {
      default: void 0,
      type: [Boolean, Object]
    }
  },
  emits: ["hydrated"],
  setup(props, { slots, emit }) {
    const result = useLazyHydration();
    if (!result.willPerformHydration) {
      return () => normalizeSlot(slots.default());
    }
    result.onHydrated(() => emit("hydrated"));
    if (props.whenIdle) {
      useHydrateWhenIdle(
        result,
        props.whenIdle !== true ? props.whenIdle : void 0
      );
    }
    if (props.whenVisible) {
      useHydrateWhenVisible(
        result,
        props.whenVisible !== true ? props.whenVisible : void 0
      );
    }
    if (props.onInteraction) {
      let events;
      if (props.onInteraction !== true) {
        events = computed(
          () => Array.isArray(props.onInteraction) ? props.onInteraction : [props.onInteraction]
        ).value;
      }
      useHydrateOnInteraction(result, events);
    }
    if (props.whenTriggered !== void 0) {
      useHydrateWhenTriggered(result, toRef(props, "whenTriggered"));
    }
    return () => normalizeSlot(slots.default());
  }
});
var LazyHydrationWrapper$1 = markRaw(LazyHydrationWrapper);

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/utils/create-hydration-wrapper.mjs
function createInnerComp(comp, { vnode: { ref: refOwner, props, children } }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = refOwner;
  return vnode;
}
function createHydrationWrapper(source, onSetup) {
  let pendingRequest = null;
  let resolvedComp;
  const loader = isFunction(source) ? source : () => Promise.resolve(source);
  const load = () => {
    let thisRequest;
    if (pendingRequest !== null) {
      return pendingRequest;
    }
    return thisRequest = pendingRequest = loader().catch((err) => {
      throw err instanceof Error ? err : new Error(String(err));
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest !== null) {
        return pendingRequest;
      }
      if (!comp) {
        console.warn(
          `Async lazily hydrated wrapped component loader resolved to undefined.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (comp && !isObject(comp) && !isFunction(comp)) {
        throw new Error(
          `Invalid async lazily hydrated wrapped component load result: ${comp}`
        );
      }
      resolvedComp = comp;
      return comp;
    });
  };
  return markRaw(
    defineComponent({
      name: "LazyHydrationWrapper",
      inheritAttrs: false,
      suspensible: false,
      emits: ["hydrated"],
      get __asyncResolved() {
        return resolvedComp;
      },
      setup(_, { emit }) {
        const instance = getCurrentInstance();
        const onError = (err) => {
          pendingRequest = null;
          handleError(err, instance, 13);
        };
        const loaded = ref(false);
        const result = useLazyHydration();
        if (typeof window === "undefined") {
          return load().then((comp) => () => createInnerComp(comp, instance)).catch((err) => {
            onError(err);
            return () => null;
          });
        }
        if (!result.willPerformHydration) {
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          load().then(() => {
            loaded.value = true;
          }).catch((err) => {
            onError(err);
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            }
            return null;
          };
        }
        const { hydrate } = result;
        result.hydrate = () => load().then(() => {
          loaded.value = true;
          void hydrate();
        }).catch((err) => {
          onError(err);
        });
        result.onHydrated(() => emit("hydrated"));
        onSetup(result);
        return () => createInnerComp(resolvedComp, instance);
      }
    })
  );
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/wrappers/hydrate-never.mjs
function hydrateNever(source) {
  return createHydrationWrapper(source, () => {
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/wrappers/hydrate-when-idle.mjs
function hydrateWhenIdle(source, timeout = 2e3) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenIdle(result, timeout);
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/wrappers/hydrate-when-visible.mjs
function hydrateWhenVisible(source, observerOpts) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenVisible(result, observerOpts);
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/wrappers/hydrate-on-interaction.mjs
function hydrateOnInteraction(source, events = ["focus"]) {
  return createHydrationWrapper(source, (result) => {
    useHydrateOnInteraction(result, events);
  });
}

// node_modules/.pnpm/vue3-lazy-hydration@1.2.1_vue@3.4.14/node_modules/vue3-lazy-hydration/dist/esm/wrappers/hydrate-when-triggered.mjs
function hydrateWhenTriggered(source, triggered) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenTriggered(result, triggered);
  });
}
export {
  LazyHydrationWrapper$1 as LazyHydrationWrapper,
  hydrateNever,
  hydrateOnInteraction,
  hydrateWhenIdle,
  hydrateWhenTriggered,
  hydrateWhenVisible,
  useHydrateOnInteraction,
  useHydrateWhenIdle,
  useHydrateWhenTriggered,
  useHydrateWhenVisible,
  useLazyHydration
};
//# sourceMappingURL=vue3-lazy-hydration.js.map
