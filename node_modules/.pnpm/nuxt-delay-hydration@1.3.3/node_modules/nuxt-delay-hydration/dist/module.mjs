import { promises } from 'node:fs';
import { useNuxt, createResolver, addTemplate, defineNuxtModule, addComponent, addServerPlugin, addPlugin } from '@nuxt/kit';
import { template } from 'lodash-es';
import { relative } from 'node:path';

function extendTypes(module, template) {
  const nuxt = useNuxt();
  const { resolve } = createResolver(import.meta.url);
  addTemplate({
    filename: `module/${module}.d.ts`,
    getContents: async () => {
      const typesPath = relative(resolve(nuxt.options.rootDir, nuxt.options.buildDir, "module"), resolve("runtime/types"));
      const s = await template({ typesPath });
      return `// Generated by ${module}
${s}
export {}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, `module/${module}.d.ts`) });
  });
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-delay-hydration",
    configKey: "delayHydration",
    compatibility: {
      nuxt: "^3.5.0"
    }
  },
  defaults: {
    mode: "mount",
    hydrateOnEvents: [],
    include: [],
    exclude: ["/_nuxt/**", "/api/**"],
    postIdleTimeout: {
      mobile: 5e3,
      desktop: 4e3
    },
    idleCallbackTimeout: 7e3,
    debug: true,
    replayClick: false
  },
  async setup(options, nuxt) {
    if (!options.hydrateOnEvents.length) {
      options.hydrateOnEvents = [
        "mousemove",
        "scroll",
        "keydown",
        "click",
        "touchstart",
        "wheel"
      ];
    }
    const { resolve, resolvePath } = createResolver(import.meta.url);
    const runtimeDir = resolve("./runtime");
    nuxt.options.build.transpile.push(runtimeDir);
    await addComponent({
      name: "DelayHydration",
      filePath: resolve("runtime/components/DelayHydration")
    });
    await addComponent({
      name: "HydrationStatus",
      filePath: resolve("runtime/components/HydrationStatus")
    });
    if (!nuxt.options.ssr) {
      console.warn(`\`'nuxt-delay-hydration'\` will only work for SSR apps, disabling module.`);
      return;
    }
    if (!options.debug && nuxt.options.dev) {
      console.warn(`\`'nuxt-delay-hydration'\` only runs in dev with \`debug\` enabled, disabling module.`);
      return;
    }
    const scripts = {};
    for (const s of ["global", "replay"]) {
      const scriptPath = await resolvePath(import.meta.url.endsWith("src/module.ts") ? `../dist/${s}` : `./${s}`);
      const scriptT = await promises.readFile(scriptPath, "utf-8");
      scripts[s] = template(scriptT)({ options });
    }
    const exports = `export const script = ${JSON.stringify(scripts.global, null, 2)}
export const replayScript = ${JSON.stringify(scripts.replay, null, 2)}
export const mode = ${JSON.stringify(options.mode)}
export const include = ${JSON.stringify(options.include)}
export const exclude = ${JSON.stringify(options.exclude)}
export const debug = ${JSON.stringify(options.debug)}`;
    const dst = addTemplate({
      filename: "delay-hydration.mjs",
      getContents: () => exports
    });
    nuxt.options.alias["#nuxt-delay-hydration/api"] = dst.dst;
    nuxt.hooks.hook("nitro:config", (config) => {
      config.virtual = config.virtual || {};
      config.virtual["#nuxt-delay-hydration/api"] = exports;
    });
    addServerPlugin(resolve(runtimeDir, "nitro-plugin"));
    addPlugin(resolve(runtimeDir, "nuxt-plugin"));
    extendTypes("nuxt-delay-hydration", async ({ typesPath }) => {
      return `
declare module 'nitropack' {
  interface NitroRouteRules {
    delayHydration?: import('${typesPath}').Mode
  }
  interface NitroRouteConfig {
    delayHydration?: import('${typesPath}').Mode
  }
}
declare module '#nuxt-delay-hydration/api' {
  export const debug: boolean
  export const script: string
  export const mode: Mode
  export const include: string[]
  export const exclude: string[]
  export const replayScript: string
}
`;
    });
  }
});

export { module as default };
