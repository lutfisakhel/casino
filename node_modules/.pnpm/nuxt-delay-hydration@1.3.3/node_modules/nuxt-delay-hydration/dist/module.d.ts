import * as _nuxt_schema from '@nuxt/schema';

declare global {
    interface Window {
        _$delayHydration: Promise<Event | string>;
    }
}
type Mode = 'init' | 'mount' | 'manual' | false;
type EventTypes = 'mousemove' | 'scroll' | 'wheel' | 'keydown' | 'click' | 'touchstart' | string;

interface ModuleOptions {
    /**
     * Which mode to use for delaying the hydration.
     */
    mode: Mode;
    /**
     * Specify the exact events that should trigger hydration.
     *
     * @default 'mousemove' | 'scroll' | 'wheel' | 'keydown' | 'click' | 'touchstart'
     */
    hydrateOnEvents: EventTypes[];
    /**
     * Specify the paths to include delayed hydration on.
     */
    include: (string | RegExp)[];
    /**
     * Specify the paths to exclude delayed hydration on.
     */
    exclude: (string | RegExp)[];
    /**
     * When waiting for an idle callback, it's possible to define a max amount of time to wait in milliseconds. This is
     * useful when there are a lot of network requests happening.
     *
     * @default 7000ms
     */
    idleCallbackTimeout: number;
    /**
     * For specific devices we can tinker with how many ms after the idle callback we should wait before we run the
     * hydration. Mobile should always be higher than desktop, desktop can remain fairly low.
     */
    postIdleTimeout: {
        mobile: number;
        desktop: number;
    };
    /**
     * When an interaction event triggered the hydration, you can replay it. For example if a user clicks a hamburger icon
     * and hydration is required to open the menu, it would replay the click once hydration.
     */
    replayClick: boolean;
    /**
     * Log details in the console on when hydration is blocked and when and why it becomes unblocked.
     *
     * @default false
     */
    debug: boolean;
}
declare const _default: _nuxt_schema.NuxtModule<ModuleOptions>;

export { type ModuleOptions, _default as default };
