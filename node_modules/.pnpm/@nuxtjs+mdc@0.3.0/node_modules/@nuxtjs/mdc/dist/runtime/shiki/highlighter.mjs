import { getHighlighter, addClassToHast } from "shikiji";
import {
  transformerNotationDiff,
  transformerNotationErrorLevel,
  transformerNotationFocus,
  transformerNotationHighlight
} from "shikiji-transformers";
export const useShikiHighlighter = createSingleton((opts) => {
  const { theme, preload, wrapperStyle } = opts || {};
  let promise;
  const getShikiHighlighter = () => {
    if (!promise) {
      promise = getHighlighter({
        themes: [
          theme?.default || theme || "dark-plus"
        ],
        langs: [
          ...preload || [],
          "diff",
          "json",
          "js",
          "ts",
          "css",
          "shell",
          "html",
          "md",
          "yaml",
          "vue",
          "mdc"
        ]
      }).then((highlighter) => {
        const themes = Object.values(typeof theme === "string" ? { default: theme } : theme || {});
        if (themes.length) {
          return Promise.all(themes.map((theme2) => highlighter.loadTheme(theme2))).then(() => highlighter);
        }
        return highlighter;
      });
    }
    return promise;
  };
  const transformers = [
    transformerNotationDiff(),
    transformerNotationFocus(),
    transformerNotationHighlight(),
    transformerNotationErrorLevel()
  ];
  const getHighlightedAST = async (code, lang, theme2, opts2) => {
    try {
      const highlighter = await getShikiHighlighter();
      const { highlights = [] } = opts2 || {};
      const themesObject = typeof theme2 === "string" ? { default: theme2 } : theme2 || {};
      const themeNames = Object.values(themesObject);
      if (themeNames.length) {
        await Promise.all(themeNames.map((theme3) => highlighter.loadTheme(theme3)));
      }
      if (lang && !highlighter.getLoadedLanguages().includes(lang)) {
        try {
          await highlighter.loadLanguage(lang);
        } catch (error) {
          if (highlights.length) {
            console.warn("[@nuxtjs/mdc] Defaulting to no language to be able to highlight lines:", error.message);
            lang = "";
          } else
            throw error;
        }
      }
      const root = highlighter.codeToHast(code.trimEnd(), {
        lang,
        themes: themesObject,
        defaultColor: false,
        transformers: [
          ...transformers,
          {
            name: "mdc:highlight",
            line(node, line) {
              if (highlights.includes(line))
                addClassToHast(node, "highlight");
              node.properties.line = line;
            }
          },
          {
            name: "mdc:newline",
            line(node) {
              if (code?.includes("\n")) {
                if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "element" && node.children[0].children.length === 1 && node.children[0].children[0].type === "text" && node.children[0].children[0].value === "") {
                  node.children = [{
                    type: "element",
                    tagName: "span",
                    properties: {
                      emptyLinePlaceholder: true
                    },
                    children: [{ type: "text", value: "\n" }]
                  }];
                  return;
                }
                const last = node.children.at(-1);
                if (last?.type === "element" && last.tagName === "span") {
                  const text = last.children.at(-1);
                  if (text?.type === "text")
                    text.value += "\n";
                }
              }
            }
          }
        ]
      });
      const preEl = root.children[0];
      const codeEl = preEl.children[0];
      preEl.properties.style = wrapperStyle ? typeof wrapperStyle === "string" ? wrapperStyle : preEl.properties.style : "";
      const styles = [];
      Object.keys(themesObject).forEach((color) => {
        const colorScheme = color !== "default" ? `.${color}` : "";
        styles.push(
          wrapperStyle ? `${colorScheme} .shiki,` : "",
          `html .${color} .shiki span {`,
          `color: var(--shiki-${color});`,
          `background: var(--shiki-${color}-bg);`,
          `font-style: var(--shiki-${color}-font-style);`,
          `font-weight: var(--shiki-${color}-font-weight);`,
          `text-decoration: var(--shiki-${color}-text-decoration);`,
          "}"
        );
        styles.unshift(
          `html${colorScheme} .shiki span {`,
          `color: var(--shiki-${color});`,
          `background: var(--shiki-${color}-bg);`,
          `font-style: var(--shiki-${color}-font-style);`,
          `font-weight: var(--shiki-${color}-font-weight);`,
          `text-decoration: var(--shiki-${color}-text-decoration);`,
          "}"
        );
      });
      return {
        tree: codeEl.children,
        className: Array.isArray(preEl.properties.class) ? preEl.properties.class.join(" ") : preEl.properties.class,
        inlineStyle: preEl.properties.style,
        style: styles.join("")
      };
    } catch (error) {
      console.warn("[@nuxtjs/mdc] Failed to highlight code block:", error.message);
      return {
        tree: [{ type: "text", value: code }],
        className: "",
        inlineStyle: "",
        style: ""
      };
    }
  };
  return {
    getHighlightedAST
  };
});
function createSingleton(fn) {
  let instance;
  return (...args) => {
    if (!instance) {
      instance = fn(...args);
    }
    return instance;
  };
}
