"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const vue = require("vue");
function createHydrationCleanup() {
  let cleanups = [];
  const onCleanup = (cb) => {
    cleanups.push(cb);
  };
  const cleanup = () => {
    cleanups = cleanups.filter((fn) => {
      fn();
      return false;
    });
  };
  return { cleanup, onCleanup };
}
function createHydrationPromise(cleanup) {
  let resolvePromise = () => {
  };
  const promise = new Promise((resolve) => {
    resolvePromise = () => {
      cleanup();
      resolve();
    };
  });
  const onResolvedPromise = (cb) => {
    void promise.then(cb);
  };
  return {
    promise,
    resolvePromise,
    onResolvedPromise
  };
}
const observers = /* @__PURE__ */ new Map();
function createHydrationObserver(options) {
  const supported = typeof IntersectionObserver !== "undefined";
  if (!supported) {
    return { supported };
  }
  const optionKey = JSON.stringify(options);
  if (observers.has(optionKey)) {
    return { supported, observer: observers.get(optionKey) };
  }
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(
      (entry) => {
        const isIntersecting = entry.isIntersecting || entry.intersectionRatio > 0;
        if (!isIntersecting || !entry.target.hydrate) {
          return;
        }
        entry.target.hydrate();
      }
    );
  }, options);
  observers.set(optionKey, observer);
  return { supported, observer };
}
const isFunction = (val) => typeof val === "function";
const isObject = (val) => val !== null && typeof val === "object";
function createInnerComp(comp, { vnode: { ref: refOwner, props, children } }) {
  const vnode = vue.createVNode(comp, props, children);
  vnode.ref = refOwner;
  return vnode;
}
function createHydrationWrapper(source, onSetup) {
  let pendingRequest = null;
  let resolvedComp;
  const loader = isFunction(source) ? source : () => Promise.resolve(source);
  const load = () => {
    let thisRequest;
    if (pendingRequest !== null) {
      return pendingRequest;
    }
    return thisRequest = pendingRequest = loader().catch((err) => {
      throw err instanceof Error ? err : new Error(String(err));
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest !== null) {
        return pendingRequest;
      }
      if (process.env.NODE_ENV === "development" && !comp) {
        console.warn(
          `Async lazily hydrated wrapped component loader resolved to undefined.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (process.env.NODE_ENV === "development" && comp && !isObject(comp) && !isFunction(comp)) {
        throw new Error(
          `Invalid async lazily hydrated wrapped component load result: ${comp}`
        );
      }
      resolvedComp = comp;
      return comp;
    });
  };
  return vue.markRaw(
    vue.defineComponent({
      name: "LazyHydrationWrapper",
      inheritAttrs: false,
      suspensible: false,
      emits: ["hydrated"],
      get __asyncResolved() {
        return resolvedComp;
      },
      setup(_, { emit }) {
        const instance = vue.getCurrentInstance();
        const onError = (err) => {
          pendingRequest = null;
          vue.handleError(err, instance, 13);
        };
        const loaded = vue.ref(false);
        const result = useLazyHydration();
        if (typeof window === "undefined") {
          return load().then((comp) => () => createInnerComp(comp, instance)).catch((err) => {
            onError(err);
            return () => null;
          });
        }
        if (!result.willPerformHydration) {
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          load().then(() => {
            loaded.value = true;
          }).catch((err) => {
            onError(err);
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            }
            return null;
          };
        }
        const { hydrate } = result;
        result.hydrate = () => load().then(() => {
          loaded.value = true;
          void hydrate();
        }).catch((err) => {
          onError(err);
        });
        result.onHydrated(() => emit("hydrated"));
        onSetup(result);
        return () => createInnerComp(resolvedComp, instance);
      }
    })
  );
}
function trackDepsOnRender(instance) {
  const componentUpdateFn = instance.effect.fn;
  const originalRender = instance.render;
  instance.render = (...args) => {
    instance.effect.fn = () => originalRender(...args);
    const result = instance.effect.run();
    instance.effect.fn = componentUpdateFn;
    instance.render = originalRender;
    return result;
  };
}
function traverseChildren(vnode, fn) {
  if (!vue.isVNode(vnode)) {
    return;
  }
  fn(
    vnode
  );
  if (vnode.children === null) {
    return;
  }
  if (Array.isArray(vnode.children)) {
    vnode.children.forEach((child) => traverseChildren(child, fn));
    return;
  }
  if (isObject(vnode.children)) {
    Object.keys(vnode.children).forEach((slotName) => {
      if (!isFunction(vnode.children[slotName])) {
        return;
      }
      const slotContent = vnode.children[slotName]();
      if (Array.isArray(slotContent)) {
        slotContent.forEach((child) => traverseChildren(child, fn));
        return;
      }
      traverseChildren(slotContent, fn);
    });
  }
}
function isAsyncWrapper(vnode) {
  var _a, _b;
  return ((_a = vnode.type) == null ? void 0 : _a.__asyncLoader) && ((_b = vnode.type) == null ? void 0 : _b.name) === "AsyncComponentWrapper";
}
function waitForAsyncComponents({ subTree }, cb) {
  const promises = [];
  traverseChildren(subTree, (vnode) => {
    if (isAsyncWrapper(vnode)) {
      promises.push(vnode.type.__asyncLoader());
    }
  });
  if (promises.length > 0) {
    void Promise.all(promises).then(cb);
    return;
  }
  cb();
}
const DOMNodeTypes = {
  ELEMENT: 1,
  TEXT: 3,
  COMMENT: 8
};
const isElement = (node) => node && node.nodeType === DOMNodeTypes.ELEMENT;
const isComment = (node) => node && node.nodeType === DOMNodeTypes.COMMENT;
const isFragmentStart = (node) => isComment(node) && (node == null ? void 0 : node.data) === "[";
const isFragmentEnd = (node) => isComment(node) && (node == null ? void 0 : node.data) === "]";
function getRootElements({
  vnode,
  subTree
}) {
  if (!vnode || vnode.el === null) {
    return [];
  }
  if (isElement(vnode.el)) {
    return [vnode.el];
  }
  const els = [];
  if (subTree && isFragmentStart(subTree.el) && isFragmentEnd(subTree.anchor)) {
    let node = vnode.el.nextSibling;
    while (node) {
      if (node && isElement(node)) {
        els.push(node);
      }
      if (node === subTree.anchor) {
        return els;
      }
      node = node.nextSibling;
    }
  }
  return els;
}
function ensureParentHasSubTreeEl(parent) {
  if (!parent || !parent.subTree) {
    return;
  }
  const parentSubTreeEl = parent.subTree.el;
  const parentOnUpdatedHook = parent.u;
  if (parent.u === null) {
    parent.u = [];
  }
  parent.u.push(() => {
    if (parent.subTree.el === null) {
      parent.subTree.el = parentSubTreeEl;
    }
    parent.u = parentOnUpdatedHook;
  });
}
function useLazyHydration() {
  const instance = vue.getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error("useLazyHydration must be called from the setup method.");
  }
  const willPerformHydration = instance.vnode.el !== null;
  instance.vnode.type.__isLazilyHydrated = true;
  if (!willPerformHydration) {
    return { willPerformHydration, onHydrated: () => {
    } };
  }
  const { cleanup, onCleanup } = createHydrationCleanup();
  const {
    promise,
    resolvePromise: hydrate,
    onResolvedPromise: onBeforeHydrate
  } = createHydrationPromise(cleanup);
  const onHydrated = (cb) => onBeforeHydrate(() => vue.nextTick(() => waitForAsyncComponents(instance, cb)));
  instance.type.__asyncLoader = () => promise;
  ensureParentHasSubTreeEl(
    instance.parent
  );
  vue.onBeforeMount(() => {
    instance.asyncDep = new Promise((r) => {
      r(true);
    });
  });
  onBeforeHydrate(() => {
    trackDepsOnRender(
      instance
    );
    instance.asyncDep = null;
  });
  vue.onUnmounted(cleanup);
  return { willPerformHydration, hydrate, onHydrated, onCleanup };
}
function useHydrateWhenIdle({
  willPerformHydration,
  hydrate,
  onCleanup
}, timeout = 2e3) {
  if (!willPerformHydration) {
    return;
  }
  if (!vue.getCurrentInstance()) {
    throw new Error(
      "useHydrateWhenIdle must be called from the setup or lifecycle hook methods."
    );
  }
  if (!("requestIdleCallback" in window)) {
    hydrate();
    return;
  }
  const idleId = requestIdleCallback(
    () => {
      hydrate();
    },
    { timeout }
  );
  onCleanup(() => {
    cancelIdleCallback(idleId);
  });
}
function useHydrateOnInteraction({
  willPerformHydration,
  hydrate,
  onCleanup
}, events = ["focus"]) {
  if (!willPerformHydration) {
    return;
  }
  const instance = vue.getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error(
      "useHydrateOnInteraction must be called from the setup method."
    );
  }
  const eventsTypes = vue.unref(events);
  vue.onMounted(() => {
    const targets = getRootElements(instance);
    const container = targets.length > 1 ? targets[0].parentElement || document : targets[0];
    const eventListenerOptions = {
      capture: true,
      once: false,
      passive: true
    };
    const listener = (event) => {
      event.stopPropagation();
      const paths = event.composedPath && event.composedPath() || event.path;
      if (!paths) {
        let el = event.target;
        while (el) {
          if (targets.includes(el)) {
            hydrate();
            return;
          }
          if (el === container) {
            return;
          }
          el = el.parentElement;
        }
        return;
      }
      targets.forEach((target) => {
        if (paths.includes(target)) {
          hydrate();
        }
      });
    };
    eventsTypes.forEach((eventType) => {
      container.addEventListener(eventType, listener, eventListenerOptions);
    });
    onCleanup(() => {
      eventsTypes.forEach((eventType) => {
        container.removeEventListener(
          eventType,
          listener,
          eventListenerOptions
        );
      });
    });
  });
}
function useHydrateWhenTriggered({
  willPerformHydration,
  hydrate,
  onCleanup
}, trigger) {
  if (!willPerformHydration) {
    return;
  }
  if (!vue.getCurrentInstance()) {
    throw new Error(
      "useHydrateWhenTriggered must be called from the setup or lifecycle hook methods."
    );
  }
  const unWatch = vue.watch(
    vue.isRef(trigger) ? trigger : () => trigger,
    (isTriggered) => {
      if (isTriggered) {
        hydrate();
      }
    },
    {
      immediate: true
    }
  );
  onCleanup(unWatch);
}
function useHydrateWhenVisible({
  willPerformHydration,
  hydrate,
  onCleanup
}, observerOptions) {
  if (!willPerformHydration) {
    return;
  }
  const instance = vue.getCurrentInstance();
  if (!instance || instance.isMounted) {
    throw new Error(
      "useHydrateWhenVisible must be called from the setup method."
    );
  }
  const { supported, observer } = createHydrationObserver(observerOptions);
  if (!supported) {
    hydrate();
    return;
  }
  vue.onMounted(() => {
    const els = getRootElements(instance);
    els.forEach((target) => {
      target.hydrate = hydrate;
      observer.observe(target);
    });
    onCleanup(() => {
      els.forEach((target) => {
        delete target.hydrate;
        observer.unobserve(target);
      });
    });
  });
}
const normalizeSlot = (slotContent) => slotContent.length === 1 ? slotContent[0] : slotContent;
const LazyHydrationWrapper = vue.defineComponent({
  name: "LazyHydrationWrapper",
  inheritAttrs: false,
  suspensible: false,
  props: {
    whenIdle: {
      default: false,
      type: [Boolean, Number]
    },
    whenVisible: {
      default: false,
      type: [Boolean, Object]
    },
    onInteraction: {
      default: false,
      type: [Array, Boolean, String]
    },
    whenTriggered: {
      default: void 0,
      type: [Boolean, Object]
    }
  },
  emits: ["hydrated"],
  setup(props, { slots, emit }) {
    const result = useLazyHydration();
    if (!result.willPerformHydration) {
      return () => normalizeSlot(slots.default());
    }
    result.onHydrated(() => emit("hydrated"));
    if (props.whenIdle) {
      useHydrateWhenIdle(
        result,
        props.whenIdle !== true ? props.whenIdle : void 0
      );
    }
    if (props.whenVisible) {
      useHydrateWhenVisible(
        result,
        props.whenVisible !== true ? props.whenVisible : void 0
      );
    }
    if (props.onInteraction) {
      let events;
      if (props.onInteraction !== true) {
        events = vue.computed(
          () => Array.isArray(props.onInteraction) ? props.onInteraction : [props.onInteraction]
        ).value;
      }
      useHydrateOnInteraction(result, events);
    }
    if (props.whenTriggered !== void 0) {
      useHydrateWhenTriggered(result, vue.toRef(props, "whenTriggered"));
    }
    return () => normalizeSlot(slots.default());
  }
});
const LazyHydrationWrapper$1 = vue.markRaw(LazyHydrationWrapper);
function hydrateNever(source) {
  return createHydrationWrapper(source, () => {
  });
}
function hydrateWhenIdle(source, timeout = 2e3) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenIdle(result, timeout);
  });
}
function hydrateWhenVisible(source, observerOpts) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenVisible(result, observerOpts);
  });
}
function hydrateOnInteraction(source, events = ["focus"]) {
  return createHydrationWrapper(source, (result) => {
    useHydrateOnInteraction(result, events);
  });
}
function hydrateWhenTriggered(source, triggered) {
  return createHydrationWrapper(source, (result) => {
    useHydrateWhenTriggered(result, triggered);
  });
}
exports.LazyHydrationWrapper = LazyHydrationWrapper$1;
exports.hydrateNever = hydrateNever;
exports.hydrateOnInteraction = hydrateOnInteraction;
exports.hydrateWhenIdle = hydrateWhenIdle;
exports.hydrateWhenTriggered = hydrateWhenTriggered;
exports.hydrateWhenVisible = hydrateWhenVisible;
exports.useHydrateOnInteraction = useHydrateOnInteraction;
exports.useHydrateWhenIdle = useHydrateWhenIdle;
exports.useHydrateWhenTriggered = useHydrateWhenTriggered;
exports.useHydrateWhenVisible = useHydrateWhenVisible;
exports.useLazyHydration = useLazyHydration;
